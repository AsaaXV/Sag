let uploadedImage = null;

// Handle image upload
document.getElementById('imageInput').addEventListener('change', function(event) {
    const file = event.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = function(e) {
            const img = new Image();
            img.onload = function() {
                uploadedImage = img;
            };
            img.src = e.target.result;
        };
        reader.readAsDataURL(file);
    }
});

// Adjust canvas size to fill the screen
function adjustCanvasSize() {
    const canvas = document.getElementById('canvas');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}

window.addEventListener('resize', adjustCanvasSize);
adjustCanvasSize();

// Generate pattern based on the selected option
function generatePattern() {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const patternType = document.getElementById('patternType').value;

    // Clear the canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    switch (patternType) {
        case 'symmetry':
            drawSymmetryPattern(ctx);
            break;
        case 'random':
            drawRandomPattern(ctx);
            break;
        case 'gradation':
            drawGradationPattern(ctx);
            break;
        case 'wave':
            drawWavePattern(ctx);
            break;
        case 'concentric':
            drawConcentricPattern(ctx);
            break;
        default:
            break;
    }
}

// Helper function to draw a custom point or image
function drawPoint(ctx, x, y, size) {
    if (uploadedImage) {
        ctx.drawImage(uploadedImage, x - size / 2, y - size / 2, size, size);
    } else {
        ctx.beginPath();
        ctx.arc(x, y, size, 0, Math.PI * 2);
        ctx.fillStyle = 'black';
        ctx.fill();
    }
}

// Symmetry pattern: Cover the entire canvas
function drawSymmetryPattern(ctx) {
    const size = 20; // Size of each dot
    const spacing = 40; // Space between dots
    for (let x = 0; x < canvas.width; x += spacing) {
        for (let y = 0; y < canvas.height; y += spacing) {
            drawPoint(ctx, x, y, size);
        }
    }
}

// Random pattern: Cover entire canvas with random dots
function drawRandomPattern(ctx) {
    const size = 20;
    const numberOfDots = 300; // Increase number of dots to fill canvas
    for (let i = 0; i < numberOfDots; i++) {
        const x = Math.random() * canvas.width;
        const y = Math.random() * canvas.height;
        drawPoint(ctx, x, y, size);
    }
}

// Gradation pattern: From center to edge
function drawGradationPattern(ctx) {
    const sizeStart = 5;
    const sizeEnd = 40;
    const numberOfLayers = 20;
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    
    for (let i = 0; i < numberOfLayers; i++) {
        const size = sizeStart + ((sizeEnd - sizeStart) * i) / numberOfLayers;
        drawPoint(ctx, centerX, centerY - i * 30, size);
    }
}

// Wave pattern: Sine wave across full width
function drawWavePattern(ctx) {
    const size = 10;
    const amplitude = 100; // Wave amplitude
    const frequency = 0.05; // Frequency of the wave
    for (let x = 0; x < canvas.width; x += 20) {
        const y = canvas.height / 2 + Math.sin(x * frequency) * amplitude;
        drawPoint(ctx, x, y, size);
    }
}

// Concentric circles pattern: Cover canvas with concentric dots
function drawConcentricPattern(ctx) {
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    const sizeStart = 10;
    const numberOfCircles = 30;
    
    for (let i = 0; i < numberOfCircles; i++) {
        const size = sizeStart + i * 10;
        drawPoint(ctx, centerX, centerY, size);
    }
}